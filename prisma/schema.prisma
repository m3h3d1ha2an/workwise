generator client {
  provider = "prisma-client"
  output   = "../generated/prisma"
}

datasource db {
  provider = "postgresql"
}

model User {
  id        String   @id
  createdAt DateTime @default(now())

  teams Team[] // 1 User -> many Teams (User is the owner/creator of teams)

  @@map("users")
}

model Member {
  id       String @id @default(uuid())
  name     String
  role     String
  capacity Int    @default(0)

  // Foreign key column pointing to the Team this member belongs to.
  // This is a required relation: every Member must have a team.
  teamId String

  // The relation field that links the Member to its Team record.
  // if the Team is updated/deleted, the Member's teamId will be updated/deleted.
  team Team @relation(fields: [teamId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  tasks Task[] // Inverse relation: one Member -> many Tasks (tasks assigned to this member).

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("members")
}

model Team {
  id   String @id @default(uuid())
  name String

  // Foreign key linking Team to the owning User (Clerk user id).
  ownerId String

  // Relation to the owner User. onUpdate: Cascade => if the User is updated,
  // onDelete: Restrict => prevents deleting the User if Teams still reference it.
  owner User @relation(fields: [ownerId], references: [id], onUpdate: Cascade, onDelete: Restrict)

  // One Team has many Projects
  projects Project[]

  // One Team has many Members
  members Member[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("teams")
}

model Task {
  id          String   @id @default(uuid())
  title       String
  description String
  status      Status   @default(Pending)
  priority    Priority @default(Low)

  // Nullable FK: if null the task is "Unassigned"
  memberId String?

  // Optional relation: task may point to a Member or be null (unassigned).
  // When a Member is deleted, the task's member field will be set to null.
  member Member? @relation(fields: [memberId], references: [id], onUpdate: Cascade, onDelete: SetNull)

  // Required FK: every Task must belong to a Project (tasks cannot be orphaned)
  projectId String

  // Required relation to Project. Deleting a Project should decide what happens to tasks:
  // consider onDelete: Cascade if you want tasks removed with project, or Restrict otherwise.
  project Project @relation(fields: [projectId], references: [id])

  // Inverse relation: a task can have many activity entries (reassign logs)
  activities Activity[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@index([projectId, memberId])
  @@map("tasks")
}

model Project {
  id   String @id @default(uuid())
  name String

  // Required FK: Project belongs to a Team
  teamId String

  // Relation to Team. If Team is updated or deleted, project will be updated or deleted.
  team Team @relation(fields: [teamId], references: [id], onUpdate: Cascade, onDelete: Cascade)

  // One Project -> many Tasks
  tasks Task[]

  createdAt DateTime @default(now())
  updatedAt DateTime @updatedAt

  @@map("projects")
}

model Activity {
  id String @id @default(uuid())

  // Nullable FK: an activity may reference a Task or be a general/team-level note
  taskId String?
  task   Task?   @relation(fields: [taskId], references: [id], onUpdate: Cascade, onDelete: SetNull)

  // Store previous and new member IDs for reassignments; nullable for non-reassign events
  fromMemberId String?
  toMemberId   String?

  // Optional: store the actor (Clerk user id) who triggered the activity
  actorId String?

  // Optional free-text note / reason
  note String?

  createdAt DateTime @default(now())

  @@index([createdAt])
  @@map("activities")
}

enum Priority {
  Low
  Medium
  High
}

enum Status {
  Pending
  InProgress
  Done
}
